using Omega, Images, InvRayTrace, Distributions, Random
using RayTrace

rng = MersenneTwister(0)

## Manually generate samples from the posterior

# Proposal distribution is chosen to be TruncatedNormal with std dev 0.1
"Proposal distribution over ω space"
function propose(rng, ω)
    ω′ = deepcopy(ω)
    for (i, p) in enumerate(ω′.data)
        ω′.data[p.first] = randsample(rng, ((@uid, i)~ TruncatedNormal(p.second, 0.1, 0, 1)), 1)[1]
    end
    ω′
end

function logratio(ω, ω′)
    a = 0
    for d in keys(ω.data)
        a = a + logpdf(TruncatedNormal(ω.data[d], 0.1, 0, 1), ω′.data[d]) - logpdf(TruncatedNormal(ω′.data[d], 0.1, 0, 1), ω.data[d])
    end
    a
end

propose_and_logratio(rng, ω::Ω) = 
    (ω′ = propose(rng, ω); (ω′ , logratio(ω, ω′)))

"logenergy"
ℓ_(ω; α = 10) = withkernel(kseα(α)) do
    # logerr(img(ω) ==ₛ InvRayTrace.img_real)
    logerr(img(ω) ==ₛ InvRayTrace.img_obs)
end

# Sample from the posterior using MH
# post_ω = mh(rng, ℓ_, 1000, defω(), propose_and_logratio)

# Sample from the posterior using Replica Exchange
logenergys = map(α -> (ω -> ℓ_(ω, α = α)), [1, 10, 100])
sim_chain_keep_n(rng, logenergy, state, samples, i) = mh(rng, logenergy, samples, state, propose_and_logratio)
samples_per_swap = 20
n_swaps = 3
post_ω = re(rng, logenergys, samples_per_swap, n_swaps, [defω() for i in 1:length(logenergys)], sim_chain_keep_n)

# Visualizing the image generated by the posterior of the scene
RayTrace.rgbimg(img(post_ω[end]).img)